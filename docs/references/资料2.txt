是的。**如果你的目标包含跨集共享、提示词缓存、无人化迭代、断点续跑**，那“全局状态表”在工程上就应该**外置成独立文件**，而不是混在每一集或每一次任务的临时上下文里。

最核心原因只有一个：**共享状态必须稳定不变，才能被复用与缓存；而分集内容必须只追加增量，才能高吞吐并行。** 把两者放同一文件会让它们互相污染。

---

## 推荐的最小文件分层

### 1 Series Global State 文件

只放跨集共享的全局对象

* 实体 canon 表
* 别名集合
* 术语与翻译偏好
* 实体映射与弃用记录
* 可选：系列设定摘要

命名示例
GCL_SERIES v0.4
MRB_SERIES v0.1

特点

* append only
* 变化频率低
* 缓存命中率高
* 所有分集都引用它

---

### 2 Episode Local Log 文件

每集一个，放本集产生的所有证据与裁决

* chunk span mention overlap override scene
* 本集临时实体也可以先写这里

命名示例
GCL_E01 v0.4 .. GCL_E12 v0.4
MRB_E01 v0.1 .. MRB_E12 v0.1

特点

* append only
* 可并行写
* 可独立重跑
* 崩溃恢复简单

---

## “外置文件”如何被使用

消费侧合成视图的顺序固定

1 读 Series Global State
2 读 Episode Local Log
3 应用 entity_map 把临时实体提升到全局实体
4 渲染本集 MRB 或输出字幕文本

这保证

* 全局一致性跨集稳定
* 分集可以乱序处理
* 不需要回写旧集

---

## 你问的“全局状态表”具体外置什么

如果只外置一件东西，那就是：

**实体表加术语偏好**

也就是

* EID canon_zh
* alias_list
* etype
* conf
* status
* optional entity_map

其余内容留在每集。

---

## 什么时候不必外置

只有一种情况可以不外置：
你永远只处理单集单文件，且不做跨集复用，也不迭代质量。
但你现在的目标明显不是这个。

---

## 最小新增块以支撑外置

为了让外置全局状态在无人化下更稳，只需要在 Series 文件里新增两个块类型即可

* ENTITY_STATUS
* ENTITY_MAP

其余沿用你已有结构。

---

如果你要我把“Series Global State 文件”的格式也压成与你现有一致的紧缩纯文本规范，我可以直接给出 **GCL_SERIES v0.4s** 和 **MRB_SERIES v0.1s** 两个完整版。

对，**在工程上，一个 idx 就够了，而且这是“正确的够”**。
不是偷懒，而是**刚好把复杂度压在最低可行点**。

但这个结论成立，有三个前提你其实已经默认接受了，我把它们说清楚。

---

## 结论一句话

> **如果“共享的只有实体与术语偏好”，
> 那么一个外置的、append-only 的 idx 文件就是最小且充分的全局状态。**

---

## 为什么一个 idx 就够

### 1 你共享的不是“内容”，而是“坐标系”

你并不需要在全局层放：

* 剧情
* 时间线
* 场景
* 句子

你只需要：

* 这个名字指向谁
* 这个词该怎么翻
* 这个别名是否等价
* 哪些实体已弃用或合并

**这本质上就是一个索引表，而不是日志。**

---

### 2 实体与术语是“低频变化、高复用”

这点非常关键：

* 实体一旦确立，改动频率极低
* 术语偏好一旦稳定，几乎不再动
* 但它们会被 **每一集、每一个 span、每一次翻译** 使用

这正是 idx 最适合承载的对象类型。

---

### 3 其余一切都应该留在 EP 日志里

如果你把这些也塞进 idx，会立刻出问题：

* overlap 裁决
* span 覆盖
* 场景划分

这些是**高频、强时序、局部有效**的，不是索引对象。

所以正确划分是：

* **idx：世界的名字表**
* **EP：世界发生了什么**

---

## 那这个 idx 实际上是什么

不是数据库意义的索引，而是：

> **一个 append-only 的、可审计的、全局命名空间声明文件**

它回答的问题只有这些：

* 这个 eid 是什么
* 它的规范显示名是什么
* 它有哪些别名
* 翻译偏好是什么
* 它是否被合并或弃用

---

## 一个 idx 里最小必须包含的字段

最小到不能再小的版本：

```
IDX_HDR
ver 1.0
mode append_only

IDX_ENTITY
eid E01
etype Person
canon_zh 金哲洙
alias_list 김철수 Kim Cheolsu
conf 0.92
status canonical

IDX_LEX
eid E01
prefer 金哲洙

IDX_ENTITY_MAP
from_eid E01_tmp
to_eid E01
conf 0.95
```

这已经足够支撑：

* 跨集实体一致性
* 翻译缓存复用
* 后期改名不返工

---

## 为什么不是“一个文件 + 很多表”

因为你现在的目标不是：

* 高并发随机写
* 复杂查询
* 事务一致性

而是：

* **稳定**
* **可追加**
* **可 diff**
* **可回放**
* **可喂给 LLM**

纯文本 idx 在这五点上都赢数据库。

---

## 什么时候一个 idx 不够

只有三种情况：

1. 你要做**复杂关系图推理**（那是另一个层）
2. 实体数量达到几十万级别（目前影视剧集不成立）
3. 你要多人协作、并发写冲突（那是工具层问题，不是模型层）

在你当前目标下，都不成立。

---

## 你这句话其实已经是设计结论

> “实体表加术语偏好，那听起来一个 idx 就够了”

这是一个**非常成熟的工程判断**，说明你已经在用“信息密度”和“变更频率”来划分系统边界，而不是凭感觉。

**idx = 世界坐标系
EP = 事件日志
MRB = 投影视图**

这三件事一旦分开，系统就会长期稳定。

--

说话者标注不是“锦上添花”，而是你这套体系从“可读文本”跃迁到“可推理认知”的关键放大器。

而且重要的是——你不需要把它做得完美，只要做到“结构上可用”，收益就已经很大。

一、为什么说话者标注在你这里“突然变得有用”

在传统字幕或转写系统里，说话者标注的收益很有限：

人类读者能自己脑补

错一点也无伤大雅

维护成本高，常被砍掉

但在你的体系里，消费方是 LLM，而 LLM 对“谁说的”极其敏感。

你现在的输入已经是：

实体稳定

场景清晰

指代尽量修复

这时加上 speaker → entity 的桥，效果是乘法级的。
